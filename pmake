#!/usr/bin/perl
# Maximillian Nibler mnibler@ucsc.edu

use strict;
use warnings;

my %lineHash;
my $countT;
my $countR;
my $key;
my @keyArr;

#read in the Makefile
resetCount();
open(DATA, "<Makefile") or die "Couldn't open file Makefile, $!";
#print "$ARGV[0]";
while(<DATA>) {
    my $parse = "$_";
    my $line = $parse =~ m/#/? "$`" : "$parse";
    print "$line";
    parseLine ($line);
}
#system( "$ARGV[0]" );
my $i = 0;
my $temp;
while ($ARGV[$i]){
    #print "looped";
    $temp = "$ARGV[$i]";
    bashLoop("$temp");
    $i ++;
}
if ($i == 0){
    $key = $keyArr[0];
    bashLoop("$key");
}
sub fileTime {
    my @filestat = stat "@_";
    if (@filestat) {
        #print "@_ ";
        my $mtime = $filestat[9];
        #print "$mtime ";
        return $mtime;
    }
    #print "no file";
    return 0;
}
sub parseAt{
    $temp = "@_";
    $temp =~ m/@/;
    $temp = "$'";
    $temp =~ s/^\s+|\s+$//g;
    sysfun ( "$temp" );
}
sub parseGCC {
    my $targ;
    my $deps;
    my $depname;
    my @splitLine;
    @splitLine = split ( / / , "@_" );
    $targ = "$lineHash{$key}{tar}{0}";
    $targ = fileTime ("$targ");
    $depname = $splitLine[-1];
    $deps = fileTime ("$depname");
    if ( $deps < $targ ){
        print "@_";
        sysfun ("@_");
    }else {
        print "pmake: '$depname' is up to date.\n";
    }
}
sub sysfun {
    my $sysret;
    system(@_);
    if ($? == -1) {
	print "failed to execute: $!\n";
    }
    elsif ($? & 127) {
    printf "child died with signal %d, %s coredump\n",
    ($? & 127),  ($? & 128) ? 'with' : 'without';
    }
    else {
	printf "child exited with value %d\n", $? >> 8;
    }
    #print "\nwhat it this : $sysret\n": 0;
}
sub bashLoop {
    my $callky;
    #print "@_";
    $callky = "@_";
    resetCount();
    my $bashout;
    $bashout = $lineHash{"$callky"}{"rec"}{"$countT"};
    while ($bashout){
        if ($bashout =~ /^@\s\S+/){
            parseAt ( "$bashout" );
        }elsif ($bashout =~ /^gcc\s\S+/){
            parseGCC ( "$bashout" );
        }else {
            print ("$bashout\n");
            sysfun ( "$bashout" );
        }
        #print "$bashout\n";
        $countT ++;
        $bashout = $lineHash{"$callky"}{"rec"}{"$countT"};
    }
}
sub resetCount{
    $countT = 0;
    $countR = 0;
}
sub addToList{
    my $addLine = "@_";
    $addLine = storeRecipe ("$addLine");
    $lineHash{"$key"}{"rec"}{"$countR"} = "$addLine";
    $countR ++;
    #print "$listStruct{head}";
    #return %listHead; 
}
sub extMacro {
    my $inpLine;
    $inpLine = "@_";
    my $mac = $inpLine =~ m/:/? "$`" : "error extract macro \n";
    $mac =~ s/^\s+|\s+$//g;
    return $mac;
}
sub extTargets{
    my $tarLine;
    my $inpline = "@_";
    $tarLine = $inpline =~ m/:/? "$'" : "error";
    $tarLine =~ s/^\s+|\s+$//g;
    #print "$tarLine\n";
    $lineHash{"$key"}{"tar"}{"$countT"} = "$tarLine";
    $countT ++;
}
sub storeRecipe{
    my $recipeLine;
    $recipeLine = "@_";
    $recipeLine =~ s/^\s+|\s+$//g;
    return $recipeLine;
}
#store
sub parseLine {
    my $nxtLine = "@_";
    if ($nxtLine =~ /^(\S+)\s*:\s*(.*?)\s*$/) {
        resetCount();
        $key = extMacro ("@_");
        my $KAsize = $#keyArr + 1;
        $keyArr[$KAsize] = "$key";
        extTargets ("@_"); 
    } elsif ($nxtLine =~ /^\s*$/){
        
    } else {
        addToList("@_");
    }
    #print "$key\n";
}
#my $time;
#$time = $lineHash{"%"}{"rec"}{1};
#print "$time"; 
my %strsignal = (
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   11 => "Segmentation fault",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped", 
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);
